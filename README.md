# GUI powered by UIFlow
## Manual / Руководство

### [По-русски]
Однажды мы познакомились с UI в Arduino IDE. Сегодня трендом компании M5Stack явлется UIFlow, поэтому от Arduino IDE пришлось отойти, а как следствие и отказаться от всех написанных удобств. В этом уроке мы начнём знакомиться с новым аналогом UI - GUI. GUI будет написан на языке программирования MicroPython.

Графический интерфейс пользователя содержит элементы, такие как: меню, кнопки, значки, списки, прогресс и статус бары, ползунки и многое другое; Все они представлены пользователю на дисплее, исполнены, как правило, в виде графических изображений.

В GUI пользователь имеет произвольный доступ (с помощью стандартных трёх кнопок: A, B, C; расположенных на лицевой панели устройства) ко всем видимым и фокусируемым экранным элементам и осуществляет непосредственное манипулирование ими.

Давайте познакомимся со структурой GUI. Давайте посмотрим на рисунок 1.

![](https://pp.userapi.com/c855520/v855520118/193bd/-fvJ3oivU1k.jpg)

Рисунок 1

Базовой единицей является класс GUIObject, который имеет поля, такие как уникальное имя, координаты, размеры, номер сцены, состояние и другие. GUIObject требует внешнюю Live-функцию, которая описывает характер поведения непосредственно самого графического элемента. При создании нового графического элемента необходимо создавать для него Live-функцию, при этом использовать стандартный набор доступных полей класса GUIObject.

Хорошо, теперь давайте посмотрим на рисунок 2. Все графические элементы имеют поле Scene, которое определяет на какой условной сцене будет присутствовать данный элемент. Все элементы со всех сцен хранятся в массиве GUIRoll (нумерация начинается с нуля). Как Вы уже поняли, каждый элемент обязательно должен иметь уникальное имя, которое располагается в поле Name. Активной сценой является та, чей номер указан в глобальной переменной GUIActiveScene. Изменять номер активной сцены разрешено  исключительно с помощью функции GUIScene(Number), где Number - есть номер желаемой сцены. 

![](https://pp.userapi.com/c855520/v855520118/193c6/BSdtZcTwqg0.jpg)

Рисунок 2

GUI имеет защиту от наложения одного графического элемента на другой. Если координаты указанные пользователем будет вызывать противоречия свободного расположения, то элементу автоматически будут присвоены новые ближайшие координаты в свободном месте. Обратите внимание на то, что не все элементы поддаются изменению размеров Width и Height, но при этом всегда могут возвращать свои текущие размеры.

![](https://pp.userapi.com/c855520/v855520118/193cf/T2vhPw-JOoI.jpg)

Рисунок 3

Поле Status (default 0) является неотъемлемым для любого из графических элементов. Данное поле определяет одно из трёх состояний (на сегодняшний день): 


- 0. Visible (элемент доступен и отображается);
- 1. Touchable (элемент доступен, отображается, доступен для взаимодействия); 
- 2. Controllable (элемент находится целиком под управлением пользователя, другие элементы недоступны в данный момент).

![](https://pp.userapi.com/c855520/v855520118/193d8/cJBv4TxX6QY.jpg)

Рисунок 4

Поле Focusable (default False) позволяет элементу принимать на себя фокус в цепи элементов сцены. Если значение оставить False, то элемент будет игнорировать Status 1 и 2. Данное поле используют, как правило, для элементов, которые применяются только для отображения информации, но бывают исключения (рисунок 5).

![](https://pp.userapi.com/c855520/v855520118/193e1/ZZXlcYAv4yY.jpg)

Рисунок 5

Если Вы планируете добавить анимацию, то используйте поле Time. Например GUIInputbox использует данное поле для мигания курсором (рисунок 6).

![](https://pp.userapi.com/c855520/v855520118/193ea/jTUaFQB1iKE.jpg)

Рисунок 6

Каждый графический элемент имеет два поля данных: TextValue для хранения текстовых данных и NumberValue для хранения числовых данных. Вы можете хранить одновременно разные данные, даже если Ваш элемент не будет использовать их. Есть родственное поле Label, используется для хранения отображаемого заголовка элемента (рисунок 7). 

![](https://pp.userapi.com/c855520/v855520118/193f3/oMkZr1RKG2Y.jpg)

Рисунок 7

Каждый графический элемент имеет необязательное поле Function (default None), которое хранит указатель на пользовательскую функцию. Представьте себе, что Вы хотите сделать кнопку при нажатии на которую изменяется значение текстового поля графического элемента с именем "human1". Создайте функцию и свяжите её с полем  Function Вашего элемента (рисунок 8). Обратите внимание на то, что пользовательская функция должна принимать в качестве аргумента указатель на экземпляр класса GUIObject вызвавшего саму функцию.

![](https://pp.userapi.com/c855520/v855520118/193fc/2txpXC4RGvI.jpg)

Рисунок 8

Хорошо, теперь, для примера, давайте попробуем создать кнопку на сцене под номером 0:

	obj = GUIObject()
	obj.Name = "myFirstButton"
	obj.Type = "button"
	obj.Label = "My button"
	obj.X = 10
	obj.Y = 19
	obj.Scene = 0
	obj.Focusable = True
	GUIAttach(obj)
	obj = None